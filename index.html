<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Monory</title>

  <!--
    Monory 最終版:
    - コード内の命名を人間が読んで分かる形に整理
    - LocalStorage: 新キーに保存 / 旧キー(monolog_*)も読み込み互換
    - お気に入り並べ替え: PC=DnD / スマホ=「≡」長押し→ドラッグ（Pointer対応）
    - 起動初期タブ: お気に入りがあればお気に入りを初期表示
  -->

  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>

  <style>
    :root {
      --bg: #0b0f1a;
      --card: #111827;
      --muted: #94a3b8;
      --text: #e5e7eb;
      --accent: #60a5fa;
      --accent2: #34d399;
      --danger: #fb7185;
      --border: rgba(148, 163, 184, 0.22);
      --shadow: 0 6px 18px rgba(0,0,0,0.25);
      --r: 14px;
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans JP";
      background: radial-gradient(1200px 700px at 20% 10%, rgba(96,165,250,0.12), transparent 60%),
                  radial-gradient(1200px 700px at 80% 30%, rgba(52,211,153,0.10), transparent 60%),
                  var(--bg);
      color: var(--text);
    }

    .app {
      max-width: 980px;
      margin: 0 auto;
      padding: 16px;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 8px 4px 14px;
    }

    .brand {
      display: flex;
      align-items: baseline;
      gap: 10px;
    }

    .brand h1 {
      margin: 0;
      font-size: 18px;
      letter-spacing: 0.2px;
    }

    .brand .sub {
      color: var(--muted);
      font-size: 12px;
    }

    .toolbar {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    button {
      appearance: none;
      border: 1px solid var(--border);
      background: rgba(17, 24, 39, 0.7);
      color: var(--text);
      border-radius: 12px;
      padding: 10px 12px;
      cursor: pointer;
      box-shadow: var(--shadow);
      font-size: 13px;
    }

    button:hover { border-color: rgba(96,165,250,0.5); }
    button:active { transform: translateY(1px); }

    .tabs {
      display: flex;
      gap: 8px;
      margin: 8px 0 12px;
    }

    .tab {
      flex: 1;
      border-radius: 12px;
      padding: 10px 12px;
      text-align: center;
      border: 1px solid var(--border);
      background: rgba(17,24,39,0.45);
      color: var(--muted);
      cursor: pointer;
      user-select: none;
    }

    .tab.active {
      color: var(--text);
      border-color: rgba(96,165,250,0.55);
      background: rgba(96,165,250,0.12);
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }

    @media (min-width: 760px) {
      .grid { grid-template-columns: 1fr 1fr; }
    }

    .card {
      border: 1px solid var(--border);
      border-radius: var(--r);
      background: rgba(17,24,39,0.55);
      padding: 12px;
      box-shadow: var(--shadow);
    }

    .card h2 {
      margin: 0 0 10px;
      font-size: 14px;
      color: var(--muted);
      font-weight: 600;
      letter-spacing: 0.1px;
    }

    .list { display: flex; flex-direction: column; gap: 8px; }

    .item {
      border: 1px solid rgba(148,163,184,0.18);
      border-radius: 12px;
      padding: 10px 10px;
      background: rgba(2,6,23,0.25);
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      gap: 10px;
      touch-action: none; /* pointerドラッグを安定させる */
    }

    .item.dragging {
      opacity: 0.65;
      border-color: rgba(96,165,250,0.65);
      background: rgba(96,165,250,0.10);
    }

    .item .name {
      font-size: 14px;
      line-height: 1.3;
    }

    .item .meta {
      font-size: 11px;
      color: var(--muted);
      margin-top: 3px;
    }

    .actions {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .iconBtn {
      width: 38px;
      height: 38px;
      padding: 0;
      display: grid;
      place-items: center;
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,0.22);
      background: rgba(17,24,39,0.55);
      box-shadow: var(--shadow);
    }

    .iconBtn.fav { border-color: rgba(52,211,153,0.45); }
    .iconBtn.del { border-color: rgba(251,113,133,0.45); }

    .handle {
      width: 38px;
      height: 38px;
      display: grid;
      place-items: center;
      border-radius: 12px;
      border: 1px dashed rgba(148,163,184,0.28);
      color: rgba(148,163,184,0.85);
      background: rgba(17,24,39,0.35);
      font-size: 16px;
      user-select: none;
    }

    .hint {
      margin-top: 10px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.5;
    }

    .row {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    input, select {
      border: 1px solid var(--border);
      background: rgba(17,24,39,0.55);
      color: var(--text);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 13px;
      outline: none;
    }

    input::placeholder { color: rgba(148,163,184,0.65); }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border: 1px solid rgba(148,163,184,0.18);
      padding: 6px 10px;
      border-radius: 999px;
      color: var(--muted);
      font-size: 12px;
    }

    .pill strong { color: var(--text); font-weight: 600; }

    .footer {
      margin-top: 16px;
      color: var(--muted);
      font-size: 12px;
      opacity: 0.9;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useEffect, useMemo, useRef, useState } = React;

    /**
     * =========================
     * 永続化キー（Monory）
     * =========================
     * 旧キー互換:
     *   - monolog_data
     *   - monolog_fav_order
     * 新キー:
     *   - monory_items
     *   - monory_favorite_order
     */
    const STORAGE_KEYS = {
      items: {
        current: 'monory_items',
        legacy: 'monolog_data',
      },
      favoriteOrder: {
        current: 'monory_favorite_order',
        legacy: 'monolog_fav_order',
      },
    };

    function safeJsonParse(text, fallback) {
      try {
        return JSON.parse(text);
      } catch {
        return fallback;
      }
    }

    function loadFromLocalStorage() {
      const rawItems =
        localStorage.getItem(STORAGE_KEYS.items.current)
        ?? localStorage.getItem(STORAGE_KEYS.items.legacy);

      const rawFavOrder =
        localStorage.getItem(STORAGE_KEYS.favoriteOrder.current)
        ?? localStorage.getItem(STORAGE_KEYS.favoriteOrder.legacy);

      const items = rawItems ? safeJsonParse(rawItems, []) : [];
      const favoriteOrder = rawFavOrder ? safeJsonParse(rawFavOrder, []) : [];

      return { items, favoriteOrder };
    }

    function saveItems(items) {
      localStorage.setItem(STORAGE_KEYS.items.current, JSON.stringify(items));
    }

    function saveFavoriteOrder(favoriteOrder) {
      localStorage.setItem(STORAGE_KEYS.favoriteOrder.current, JSON.stringify(favoriteOrder));
    }

    function unique(array) {
      return Array.from(new Set(array));
    }

    function App() {
      const [{ items, favoriteOrder }, setData] = useState(() => loadFromLocalStorage());

      // タブ: 'active' | 'favorites'
      const [activeTab, setActiveTab] = useState('active');

      // 初期タブ: お気に入りが1件以上なら favorites
      useEffect(() => {
        const hasAnyFavorite = items.some(it => !!it.isFavorite);
        setActiveTab(hasAnyFavorite ? 'favorites' : 'active');
        // eslint-disable-next-line react-hooks/exhaustive-deps
      }, []);

      // 永続化
      useEffect(() => saveItems(items), [items]);
      useEffect(() => saveFavoriteOrder(favoriteOrder), [favoriteOrder]);

      // favoriteOrder を整備（お気に入りIDだけ保持）
      useEffect(() => {
        const favoriteIds = items.filter(it => it.isFavorite).map(it => it.id);
        const next = unique(favoriteOrder.filter(id => favoriteIds.includes(id)).concat(favoriteIds));
        if (JSON.stringify(next) !== JSON.stringify(favoriteOrder)) {
          setData(prev => ({ ...prev, favoriteOrder: next }));
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
      }, [items]);

      const favoriteItems = useMemo(() => {
        const byId = new Map(items.map(it => [it.id, it]));
        const ordered = favoriteOrder.map(id => byId.get(id)).filter(Boolean);
        const rest = items.filter(it => it.isFavorite && !favoriteOrder.includes(it.id));
        return ordered.concat(rest);
      }, [items, favoriteOrder]);

      const activeItems = useMemo(() => items.filter(it => it.isActive), [items]);

      function addItem(name) {
        const trimmed = (name || '').trim();
        if (!trimmed) return;
        const id = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
        setData(prev => ({
          ...prev,
          items: [
            {
              id,
              name: trimmed,
              category: '未分類',
              isActive: true,
              isFavorite: false,
              createdAt: new Date().toISOString(),
            },
            ...prev.items,
          ],
        }));
      }

      function toggleFavorite(id) {
        setData(prev => {
          const nextItems = prev.items.map(it => it.id === id ? { ...it, isFavorite: !it.isFavorite } : it);
          const isFavNow = nextItems.find(it => it.id === id)?.isFavorite;

          let nextFavOrder = prev.favoriteOrder;
          if (isFavNow) {
            nextFavOrder = unique([id, ...prev.favoriteOrder]);
          } else {
            nextFavOrder = prev.favoriteOrder.filter(x => x !== id);
          }

          return { ...prev, items: nextItems, favoriteOrder: nextFavOrder };
        });
      }

      function toggleActive(id) {
        setData(prev => ({
          ...prev,
          items: prev.items.map(it => it.id === id ? { ...it, isActive: !it.isActive } : it),
        }));
      }

      function removeItem(id) {
        setData(prev => ({
          ...prev,
          items: prev.items.filter(it => it.id !== id),
          favoriteOrder: prev.favoriteOrder.filter(x => x !== id),
        }));
      }

      // =========================
      // お気に入り並べ替え（スマホ対応）
      // =========================
      const dragStateRef = useRef({
        pointerId: null,
        draggingId: null,
        startIndex: -1,
        overIndex: -1,
        isDragging: false,
        longPressTimer: null,
        armed: false,
      });

      function reorderFavoriteOrder(fromIndex, toIndex) {
        if (fromIndex === toIndex) return;
        setData(prev => {
          const order = [...prev.favoriteOrder];
          const item = order[fromIndex];
          order.splice(fromIndex, 1);
          order.splice(toIndex, 0, item);
          return { ...prev, favoriteOrder: order };
        });
      }

      // PC: HTML5 Drag & Drop
      function onDragStartHtml5(e, id) {
        e.dataTransfer.setData('text/plain', id);
        e.dataTransfer.effectAllowed = 'move';
      }

      function onDragOverHtml5(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
      }

      function onDropHtml5(e, dropIndex) {
        e.preventDefault();
        const draggedId = e.dataTransfer.getData('text/plain');
        const fromIndex = favoriteOrder.indexOf(draggedId);
        if (fromIndex >= 0) reorderFavoriteOrder(fromIndex, dropIndex);
      }

      // スマホ: Pointer長押し→ドラッグ
      const [reorderUiTick, setReorderUiTick] = useState(0);

      function onPointerDownHandle(e, id, index) {
        const st = dragStateRef.current;
        st.pointerId = e.pointerId;
        st.draggingId = id;
        st.startIndex = index;
        st.overIndex = index;
        st.isDragging = false;

        clearTimeout(st.longPressTimer);
        st.longPressTimer = setTimeout(() => {
          st.isDragging = true;
          st.armed = true;
          try { e.target.setPointerCapture(e.pointerId); } catch {}
          if (navigator.vibrate) navigator.vibrate(12);
          setReorderUiTick(t => t + 1);
        }, 220);
      }

      function onPointerMoveItem(e, hoverIndex) {
        const st = dragStateRef.current;
        if (!st.armed || !st.isDragging) return;
        if (st.draggingId == null) return;
        st.overIndex = hoverIndex;
        setReorderUiTick(t => t + 1);
      }

      function onPointerUpAny() {
        const st = dragStateRef.current;
        clearTimeout(st.longPressTimer);

        if (st.armed && st.isDragging) {
          const from = st.startIndex;
          const to = st.overIndex;
          if (from >= 0 && to >= 0) reorderFavoriteOrder(from, to);
        }

        st.pointerId = null;
        st.draggingId = null;
        st.startIndex = -1;
        st.overIndex = -1;
        st.isDragging = false;
        st.armed = false;
        setReorderUiTick(t => t + 1);
      }

      useEffect(() => {
        window.addEventListener('pointerup', onPointerUpAny);
        window.addEventListener('pointercancel', onPointerUpAny);
        return () => {
          window.removeEventListener('pointerup', onPointerUpAny);
          window.removeEventListener('pointercancel', onPointerUpAny);
        };
      }, []);

      // =========================
      // バックアップ（Monory名）
      // =========================
      function exportBackup() {
        const payload = {
          version: 2,
          exportedAt: new Date().toISOString(),
          items,
          favoriteOrder,
        };
        const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
        const a = document.createElement('a');
        const now = new Date();
        const y = now.getFullYear();
        const m = String(now.getMonth() + 1).padStart(2, '0');
        const d = String(now.getDate()).padStart(2, '0');
        const hh = String(now.getHours()).padStart(2, '0');
        const mm = String(now.getMinutes()).padStart(2, '0');
        a.download = `monory_backup_${y}${m}${d}_${hh}${mm}.json`;
        a.href = URL.createObjectURL(blob);
        a.click();
        URL.revokeObjectURL(a.href);
      }

      function importBackup(file) {
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          const text = String(reader.result || '');
          const data = safeJsonParse(text, null);
          if (!data) return;

          if (data.version === 2 && Array.isArray(data.items)) {
            setData({
              items: data.items,
              favoriteOrder: Array.isArray(data.favoriteOrder) ? data.favoriteOrder : [],
            });
            return;
          }

          // 旧形式: items配列のみ
          if (Array.isArray(data)) {
            setData({ items: data, favoriteOrder: [] });
          }
        };
        reader.readAsText(file);
      }

      // =========================
      // UI
      // =========================
      const [newName, setNewName] = useState('');
      const fileInputRef = useRef(null);

      const tabCounts = useMemo(() => {
        const fav = items.filter(it => it.isFavorite).length;
        const act = items.filter(it => it.isActive).length;
        return { fav, act, total: items.length };
      }, [items]);

      return (
        <div className="app">
          <header>
            <div className="brand">
              <h1>Monory</h1>
              <div className="sub">お気に入り整理・使用中管理</div>
            </div>
            <div className="toolbar">
              <button onClick={exportBackup}>バックアップを書き出し</button>
              <button onClick={() => fileInputRef.current?.click()}>バックアップを読み込み</button>
              <input
                ref={fileInputRef}
                type="file"
                accept="application/json"
                style={{ display: 'none' }}
                onChange={(e) => importBackup(e.target.files?.[0])}
              />
            </div>
          </header>

          <div className="tabs">
            <div className={"tab " + (activeTab === 'active' ? 'active' : '')} onClick={() => setActiveTab('active')}>
              使用中 <span className="pill"><strong>{tabCounts.act}</strong></span>
            </div>
            <div className={"tab " + (activeTab === 'favorites' ? 'active' : '')} onClick={() => setActiveTab('favorites')}>
              お気に入り <span className="pill"><strong>{tabCounts.fav}</strong></span>
            </div>
          </div>

          <div className="grid">
            <div className="card">
              <h2>追加</h2>
              <div className="row">
                <input
                  value={newName}
                  onChange={(e) => setNewName(e.target.value)}
                  placeholder="モノの名前"
                  style={{ flex: 1, minWidth: 180 }}
                />
                <button onClick={() => { addItem(newName); setNewName(''); }}>追加</button>
              </div>
              <div className="hint">
                追加すると「使用中」に入るよ。お気に入りにするとお気に入りタブに並ぶ。
              </div>
            </div>

            <div className="card">
              <h2>状態</h2>
              <div className="row">
                <span className="pill">総数 <strong>{tabCounts.total}</strong></span>
                <span className="pill">使用中 <strong>{tabCounts.act}</strong></span>
                <span className="pill">お気に入り <strong>{tabCounts.fav}</strong></span>
              </div>
              <div className="hint">
                ※ 並び替え順は端末ローカル保存（別端末へはバックアップで移す）。
              </div>
            </div>

            {activeTab === 'active' ? (
              <div className="card" style={{ gridColumn: '1 / -1' }}>
                <h2>使用中リスト</h2>
                <div className="list">
                  {activeItems.length === 0 && (
                    <div className="hint">使用中は空じゃね。</div>
                  )}
                  {activeItems.map(it => (
                    <div key={it.id} className="item">
                      <div>
                        <div className="name">{it.name}</div>
                        <div className="meta">{it.category || '未分類'} · {it.createdAt?.slice(0,10) || ''}</div>
                      </div>
                      <div className="actions">
                        <button className="iconBtn fav" onClick={() => toggleFavorite(it.id)} title="お気に入り">
                          {it.isFavorite ? '★' : '☆'}
                        </button>
                        <button className="iconBtn" onClick={() => toggleActive(it.id)} title="使用中切替">
                          {it.isActive ? '⏸' : '▶'}
                        </button>
                        <button className="iconBtn del" onClick={() => removeItem(it.id)} title="削除">✕</button>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            ) : (
              <div className="card" style={{ gridColumn: '1 / -1' }}>
                <h2>お気に入り（並べ替え）</h2>
                <div className="hint">
                  PC: 行をドラッグ。スマホ: 左の「≡」を長押ししてから上下に移動。
                </div>
                <div className="list">
                  {favoriteItems.length === 0 && (
                    <div className="hint">お気に入りはまだ無いみたい。</div>
                  )}
                  {favoriteItems.map((it, index) => {
                    const st = dragStateRef.current;
                    const isDragging = st.isDragging && st.draggingId === it.id;
                    const isOver = st.isDragging && st.overIndex === index;

                    return (
                      <div
                        key={it.id}
                        className={'item ' + (isDragging ? 'dragging' : '')}
                        draggable
                        onDragStart={(e) => onDragStartHtml5(e, it.id)}
                        onDragOver={onDragOverHtml5}
                        onDrop={(e) => onDropHtml5(e, index)}
                        onPointerMove={(e) => onPointerMoveItem(e, index)}
                        style={isOver ? { borderColor: 'rgba(96,165,250,0.7)' } : null}
                      >
                        <div style={{ display: 'flex', gap: 10, alignItems: 'center' }}>
                          <div
                            className="handle"
                            title="長押しで並べ替え"
                            onPointerDown={(e) => onPointerDownHandle(e, it.id, index)}
                          >
                            ≡
                          </div>
                          <div>
                            <div className="name">{it.name}</div>
                            <div className="meta">{it.category || '未分類'}</div>
                          </div>
                        </div>
                        <div className="actions">
                          <button className="iconBtn fav" onClick={() => toggleFavorite(it.id)} title="お気に入り">★</button>
                          <button className="iconBtn" onClick={() => toggleActive(it.id)} title="使用中切替">
                            {it.isActive ? '⏸' : '▶'}
                          </button>
                          <button className="iconBtn del" onClick={() => removeItem(it.id)} title="削除">✕</button>
                        </div>
                      </div>
                    );
                  })}
                </div>
              </div>
            )}
          </div>

          <div className="footer">
            保存先: LocalStorage（この端末のこのブラウザ）
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
